### Document 1: Namespace
- --- separates YAML documents; this file defines four resources in sequence.[4]
- apiVersion: v1 uses the core API group for core resources like Namespace and Service.[2]
- kind: Namespace declares a Namespace object (a logical partition in the cluster).[10]
- metadata: starts the object’s identifying data.[2]
  - name: game-2048 sets the namespace name that will scope namespaced resources created later.[10]

### Document 2: Deployment
- --- starts the next resource document.[4]
- apiVersion: apps/v1 selects the Deployment API version in the apps group.[1]
- kind: Deployment declares a Deployment, which manages ReplicaSets and Pods.[1]
- metadata: defines identity and placement for this Deployment.[2]
- namespace: game-2048 places this Deployment in the previously created Namespace.[10]
- name: deployment-2048 assigns a unique name within that Namespace.[2]
- spec: begins the desired state for the Deployment.[1]
- selector: defines which Pods this Deployment “owns” by label matching.[1]
- matchLabels: app.kubernetes.io/name: app-2048 sets the label selector that must match the Pod template’s labels.[1]
- replicas: 3 requests three identical Pod replicas for availability and scaling.[5]
- template: specifies the Pod template the Deployment will use to create Pods.[1]
- template.metadata: labels: app.kubernetes.io/name: app-2048 applies the same label so the selector matches these Pods.[1]
- template.spec: begins the Pod spec for containers and other runtime settings.[1]
  - containers: defines the list of containers in each Pod.[1]
    - image: public.ecr.aws/l6m2t8p7/docker-2048:latest sets the container image from a registry (public ECR here).[1]
      - imagePullPolicy: Always instructs the kubelet to pull the image on every start for this container.[1]
      - name: app-2048 assigns a human‑readable container name.[1]
      - ports: lists container ports to document and enable service targeting.[5]
        - - containerPort: 80 declares the container listens on TCP 80, used by Services as a targetPort.[5]

### Document 3: Service
- --- starts the Service resource document.[4]
- apiVersion: v1 uses the core API for Service.[11]
- kind: Service declares a stable virtual IP/DNS that groups Pods and exposes them on the network.[11]
- metadata: namespace: game-2048 scopes the Service to the same Namespace as the Pods.[10]
- metadata: name: service-2048 names the Service that Ingress will reference.[11]
- spec: begins the Service configuration.[11]
- ports: defines how the Service listens and forwards traffic.[11]
- - port: 80 is the Service port clients use to reach the Service.[11]
- targetPort: 80 is the container port on the selected Pods that receives traffic.[11]
- protocol: TCP sets the transport protocol (default is TCP).[11]
- type: NodePort exposes the Service on a high port on every node in addition to ClusterIP.[11]
- selector: app.kubernetes.io/name: app-2048 tells the Service which Pods to send traffic to by matching labels.[11]

### Document 4: Ingress (for ALB on EKS)
- --- starts the Ingress resource document.[4]
- apiVersion: networking.k8s.io/v1 uses the stable networking API for Ingress.[12]
- kind: Ingress declares HTTP/HTTPS routing rules that send external traffic to Services.[12]
- metadata: namespace: game-2048 ensures the Ingress and referenced Service live in the same Namespace.[10]
- metadata: name: ingress-2048 sets the Ingress name.[12]
- annotations: alb.ingress.kubernetes.io/scheme: internet-facing requests a public ALB when using the AWS Load Balancer Controller.[13][14]
- annotations: alb.ingress.kubernetes.io/target-type: ip configures the ALB to register Pod IPs directly rather than node ports.[14][13]
- spec: begins the Ingress rules.[12]
- ingressClassName: alb selects the IngressClass implemented by the AWS Load Balancer Controller.[15][13]
- rules: declares host/path routing logic.[12]
- - http: paths: defines HTTP rules for incoming requests.[12]
- - path: / with pathType: Prefix routes all paths under /.[12]
- backend: service: name: service-2048 selects the Service as the backend target.[12]
- backend: service: port: number: 80 forwards to the Service’s port 80.[12]

### Relationships and traffic flow
- Namespace scopes all three resources so their names only need to be unique within game-2048.[10]
- Deployment creates and maintains three Pods labeled app.kubernetes.io/name=app-2048.[1]
- Service service-2048 selects those Pods by label and exposes them inside the cluster (ClusterIP) and via NodePort on every node.[11]
- Ingress ingress-2048 (class alb) uses the AWS Load Balancer Controller to provision an ALB and route external HTTP traffic to service-2048.[13][15][12]

### EKS‑specific notes for this Ingress
- With target-type: ip, the ALB targets Pod IPs behind the Service; a ClusterIP Service is sufficient and NodePort is not required for this mode.[14][13]
- The internet-facing scheme makes the ALB public; use private for internal‑only exposure.[13][14]
